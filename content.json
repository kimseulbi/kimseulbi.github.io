{"pages":[],"posts":[{"title":"","text":"","link":"/2019/04/12/naverthechconcent/"},{"title":"Type Ahead","text":"구현내용 fetch API를 통해 api를 받아와서 JSON형태로 가공 JSON데이터를 input에 입력 할때 데이터만 필터링 필터링된 문자 하이라이트 표시 🏷 fetch API 웹피이지 전체를 리로드하지 않고 일부분만을 리로드하고 비동기싱으로 데이터를 불러와 작업하는 XMLHttpRequest 객체 web에서 비동기로 요청하기 위해서는 XHR객체사용IE에서 ajax 요청을 보내기가 까다로워서 jquery AJAX나 axios, superagent같은 라이브러리 등장 XHR의 부족한 부분을 보완하기 위해서 Fetch API를 도입 axios는 XHR을 사용하는데, Service Worker등의 최신 기숭이 XHR을 지원하지 않으므로 Service worker를 사용할 예정이라면 Fetch API를 사용해야 합니다.create-react-app 에도 Service Worker가 있습니다. 1234// fetch apifetch(endpoint) .then(blob =&gt; blob.json()) .then(data =&gt; cities.push(...data)); code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//endpoint변수에 주소를 담음const endpoint = \"https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json\";// cities 초기화, 검색어에 따라서 변환const cities = [];// fetch apifetch(endpoint) // 객체의 값을 json으로 변환 .then(blob =&gt; blob.json()) // data에 'cities에 ...data'를 push .then(data =&gt; cities.push(...data));// 기본구조: fetch('주소', 설정객체).then(콜백).catch(콜백);function findMatches(wordToMatch, cities) { //wordToMatch : input text value // 여기서 우리는 도시나 제대로 검색된 것과 일치하는지 알아내야함 return cities.filter(place =&gt; { // RegExp : 사용하면 문자열을 검색하고 문자열의 텍스트를 바꾸는 데 사용할 수 있는 패턴인 일반 표현식을 사용할 수 있습니다 const regex = new RegExp(wordToMatch, \"gi\"); // RegExp match매소드 : 대응되는 문자열을 찾는 RegExp 메소드입니다. 정보를 가지고 있는 배열을 반환합니다. 대응되는 문자열을 찾지 못했다면 null을 반환합니다. return place.city.match(regex) || place.state.match(regex); });}// toString() : 숫자를 문자형으로 변환// replace() : 문자열의 특정 부분을 바꾼 새 문자열을 생성할때 사용function numberWithCommas(x) { return x.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");}function displayMatches() { //일치하는 값을 matchArray에 담기 const matchArray = findMatches(this.value, cities); //this = target.event const html = matchArray .map(place =&gt; { const regex = new RegExp(this.value, \"gi\"); const cityName = place.city.replace( regex, `&lt;span class=\"hl\"&gt;${this.value}&lt;/span&gt;` ); const stateName = place.state.replace( regex, `&lt;span class=\"hl\"&gt;${this.value}&lt;/span&gt;` ); return ` &lt;li&gt; &lt;span class=\"name\"&gt;${cityName}, ${stateName}&lt;/span&gt; &lt;span class=\"population\"&gt;${numberWithCommas(place.population)}&lt;/span&gt; &lt;/li&gt; `; }) .join(\"\"); suggestions.innerHTML = html;}const searchInput = document.querySelector(\".search\");const suggestions = document.querySelector(\".suggestions\");searchInput.addEventListener(\"change\", displayMatches);searchInput.addEventListener(\"keyup\", displayMatches);","link":"/2019/04/12/ Type Ahead/"},{"title":"JAVASCRIPT 스터디 2주차 복습","text":"Grammar Control Characters(제어문자) : 눈에 보이지 않지만 여러가지 제어를 위해 삽입되는 문자. White Space(공백) : 공백 (띄어쓰기)를 컴퓨터가 인식하게 하는 문자. Line terminators(줄바꿈) : 말 그대로 컴퓨터가 줄바꿈을 인식할 수 있게하는 문자. Comments(주석) : 실제 코드로 작성되어있긴 하지만, 번역기가 코드를 컴퓨터가 이해할 수 있는 더 저차원의 언어로 해석할 때 명령으로 인식하지 않는 부분. 사람들이 코드 내용을 편하게 이해하거나 쉽게 기억하기 위해 사용. Keywords(키워드) : 미리 약속으로 정해둔 단어들. 이 키워드를 해석기가 만나면 키워드에 미리 지정된 방식으로 내용으로 인식. Literals(리터럴) : 더 이상 나눌 수 없는 값을 표현. 예를 들면 3, ‘3’, [] 등… Statement empty statement : 공문(빈문). block statement : 중문({}) control statement : 제어문 expression statement : 식문 (variable) declare statement : (변수)선언문 선언, 할당123var a; // 선언var a = 123; //값 할당a = 222; // 재할당 Expression(표현식)코드 중에 값으로 변환될 수 있는 부분을 표현식이라고 부릅니다. 함수 표현식12345// 함수 익명 표현식// 자바스크립트는 1급 객체라서 변수에 함수를 넣을 수 있습니다.var count = function() { return count;}; 자바스크립트가 1급객체이기 때문에 가능한 것 함수를 변수나 데이터에 할당 할 수 있습니다. 함수를 인자로 전달 할 수 있다. 함수를 리턴 할 수 있다. Type (Primitive(원시), Reference(참조)) 원시타입 참조타입 Number Object String Boolean Undefined Null Symbol typeof12typeof []; // 'object'// typeof는 타입을 알려줌 배열 타입자바스크립트 배열은 가짜고 obj이다배열은 JavaScript에 내장되어 있는 자료구조이며 배열은 객체의 일종이지만, 내부적으로 특별하게 취급되어 일반적인 객체들과는 다른 특징을 갖고 있습니다. Array.isArray어떤 값이 배열인지 아닌지 판별하기 위해서 Array.isArray 정적 메소드를 사용합니다. 12Array.isArray([]); // trueArray.isArray({}); // false Truthy &amp; Falsytrue -&gt; truthy, false -&gt; falsy라고 부릅니다. truthy falsy falsy 말고 모든것 false null undefined 0 NaN ‘’ Truthy &amp; Falsy 실습 12345678910111213141516171819202122232425262728function test(str) { // true가 아니면 return if (!str) return; // true이면 '문자열을 들어옴' 호출 return \"문자열을 들어옴\";}test(\"hello\"); // 문자열을 들어옴// 삼항연산자// '' 빈값이 생기면 삼항 연산자 사용이 필요 없음function test2(str) { // true ? 호출 : '' // false ? '' : 호출 return str ? \"문자열을 들어옴\" : \"\";}test2(\"hello\"); // 문자열을 들어옴var test3 = function(str) { // true &amp;&amp; true -&gt; 뒤가 호출 return str &amp;&amp; \"문자열을 들어옴\";};test3(\"hello\"); // 문자열을 들어옴let test4 = function(str) { // true || true -&gt; 앞이 호출 return str || \"아무것도 없음\";};test4(\"hello\"); // hello Scope특정 변수가 유효한 코드 상의 유효 범위를 가지고 스코프라고 합니다. 변수 const let var 스코프 블록 스코프 블록 스코프 함수 스코프 재할당 X O O 재선언 X X O 호이스팅 X X O 사용 권장 1 순위 2 순위 3 순위 🏷 호이스팅 함수 또는 var변수의 선언부를 현재 scope의 최상단으로 끌어올려지는 현상입니다.var로 선언된 변수는 내부적으로 함수 혹은 파일의 맨위로 끌어올려지는 과정을 호이스팅이리고 한다. 변수의 선언만 위로 끌어올려질 뿐 값을 대입하는 과정은 코드의 순서에 맞게 이루어지기 때문에, 대입에 일어나기 전에 변수의 값을 읽으면 undefined가 불러와지게 됩니다. 참고한 자료및 주소https://www.bsidesoft.com/?p=4074https://medium.com/@soeunlee/javascript%EC%97%90%EC%84%9C-%EC%99%9C-%ED%95%A8%EC%88%98%EA%B0%80-1%EA%B8%89-%EA%B0%9D%EC%B2%B4%EC%9D%BC%EA%B9%8C%EC%9A%94-cc6bd2a9ecac","link":"/2019/03/17/2주차복습과제/"},{"title":"JAVASCRIPT 스터디 2주차 예습","text":"값, 식, 문 Primitive Type &amp; Reference type 차이점 및 이해 (o) Truthy &amp; Falsy 차이점 및 이해 (o) 값값은 프로그램에 의해 조작될 수 있는 대상을 말합니다. 값은 다양한 방법으로 생성할 수있으며 프로그래밍 언어에서 값을 생성하는 가장 쉬운 방법은 리터럴을 사용하는 것입니다. 12341; // 정수 리터럴2.5; // 부동 소수점 리터럴(\"hello\"); // 문자열 리터럴true; // 진리값 리터럴 변수값에 이름을 붙여서 다시 쓸 수 있게 만드는 기능 const let var 스코프 블록 스코프 블록 스코프 함수 스코프 재대입 X O O 재선언 X X O 호이스팅 X X O 사용 권장 1 순위 2 순위 3 순위 🏷 호이스팅\\호이스팅이란 var로 선언된 변수나 function의 선언부를 현재 scope의 최상단으로 끌어올려지는 현상입니다. 식별자변수의 이름은 모두 식별자입니다. 타입값의 종류를 가지고 자료형이라고 부릅니다. 12typeof 1; // 'number'typeof \"hello\"; // 'string' 식문조건문경우의 수 if…elseif...else 구문을 사용하면 조건에 따라 특정 영역의 코드를 실행시키거나 실행시키지 않을 수 있습니다. 1234567891011function translateColor(english) { if (english === \"red\") { return \"빨강색\"; } else if (english === \"blue\") { return \"파랑색\"; } else if (english === \"purple\" || english === \"violet\") { return \"보라색\"; } else { return \"일치하는 색깔이 없습니다.\"; }} switch변수에 대해 많은 경우 사용 123456789101112131415161718function translateColor(english) { let result; switch (english) { case \"red\": result = \"빨강\"; break; case \"blue\": result = \"파랑\"; break; case \"purple\": case \"violet\": result = \"보라\"; break; default: result = \"일치하는 색깔이 없습니다.\"; } return result;} 반복문여러 번 반복할 경우 while특정 조건을 만족하는 한 코드를 반복해서 실행 12345678let i = 0;while (i &lt; 5) { // 위 괄호의 값이 `true`인 동안에서 // 이 안쪽의 코드를 반봅해서 실행시킵니다. console.log(`현재 i의 값: ${i}`); i++; // 갱신} do…whilewhile 구문과 사용법은 크게 다르지 않으나, 내부 코드를 무조건 한번은 실행시킨다는 차이점이 있습니다. 123do { console.log(\"do...while\");} while (false); // 절대 `true`가 될 수 없지만, 루프는 1회 실행합니다. for초기값을 정할 수 있고 갱신을 위한 코드가 짧은 경우 for구문 while구문을 사용해야 코드가 깔끔해집니다. 123456// for문const arr = [1, 2, 3, 4, 5];for (let i = 0; i &lt; arr.length; i++) { console.log(`배열의 ${i + 1} 번째 요소는 ${arr[i]} 입니다.`);} 123456// forEachconst arr = [1, 2, 3, 4, 5];arr.forEach((item, index) =&gt; { console.log(`배열의 ${index + 1} 번째 요소는 ${item} 입니다.`);}); 123456// for...ofconst arr = [1, 2, 3, 4, 5];for (let item of arr) { console.log(`현재 요소는 ${item}입니다.`);} Primitive Type &amp; Reference type (원시타입 &amp; 참조타입) 원시타입 참조타입 Number Object String Boolean Undefined Null Symbol 함수도 객체의 일종입니다. 원시타입의 특징원시타입은 값 자체의 내용을 변경할 수 있는 방법이 없습니다. 이런 성징은 불변성이라고 합니다. 기존 문자열의 내용을 바꾸는 것이 아니라 새 문자열을 반환합니다. 123456let str1 = \"Hello world\";let str2 = st1;console.log(str2); // \"Hello world\" 출력str1 = \"Nice to meet you\";console.log(str2); // \"Hello world\" 출력 원시타입은 데이터를 복사하여 전달하기 때문에 원본 데이터가 변경되어 쌓이고 복사된 데이터에 영향을 받지 않습니다. 참조타입의 특징참조(Reference)란, 객체가 컴퓨터 메모리 상에서 어디에 저장되었는지를 가리키는 값입니다. JavaScript에서는 우리가 참조를 직접 읽거나 조작할 수 없습니다. 하지만, 언어를 제대로 이해하기 위해서 참조가 무엇인지 알아야 할 필요는 있습니다. 참조를 통해 메모리에 저장되어 있는 객체에 접근해서 해당 객체의 속성을 읽습니다.이런 동작을 역참조(dereference)라고 합니다. 12const obj = { prop: 1 };obj.prop; // `obj`를 통해 역참조된 객체의 속성을 읽어왔습니다. 123let obj1 = { name: \"kim\" };let obj2 = obj1;console.log(obj2); // {name: \"kim\"} 출력 변수 obj2은 변수 obj1이 가리키고 있는 { name: “kim” }를 가르키고 있어 { name: “kim” }으로 출력이 되었습니다. 참조타입과 원시타입의 비교연산자12345// 원시타입 비교 연산자const str1 = \"hello\";const str2 = \"hello\";console.log(str1 === str2); // true 원시타입은 값을 비교하기 때문에 true가 나옵니다. 1234const obj1 = { name: \"kim\" };const obj2 = { name: \"kim\" };console.log(obj1 === obj2); // false 객체의 내용을 비교하는 것이 아니라 객체의 참조를 비교합니다. 우리가 생성자나 리터럴을 이용해 객체를 생성하면, 객체는 매 번 새로 생성되어 각각 메모리의 다른 위치에 저장됩니다.그래서 내용이 똑같아 보이는 두 객체일지라도 그에 대한 참조는 서로 다른것입니다. 하지만 두참조가 정말로 같은 객체를 가리키고 있다면 등호연산자는 true를 반환합니다. 123const obj1 = {};const obj2 = obj1;obj1 === obj2; // true 객체의 내용을 통해 비교하고 싶다면, 깊은 비교 기능을 지원하는 라이브러리를 이용해야합니다. 참고하기 좋은 영상[서형이에게물어봐야함] Truthy &amp; FalsyJS에서는 boolean 타입이 와야 하는 자리에 다른 타입의 값이 와도 에러가 나지 않고 실행됩니다. 12345678// 1은 Truthyif (1) { console.log(\"이 코드는 실행됩니다.\");}// 0은 Falsyif (0) { console.log(\"이 코드는 실행되지 않습니다.\");} true -&gt; truthy, false -&gt; falsy라고 부릅니다. truthy falsy falsy 말고 모든것 false null undefined 0 NaN ‘’ 짧은 코드 작성은 가능하지만 코드의 의미가 불분명해지거나 논리적으로 놓치는 부분이 생길 수 있기 때문에 주의하여 사용합니다. 참고한 자료및 주소https://m.blog.naver.com/PostView.nhn?blogId=gi_balja&amp;logNo=221137914754&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F","link":"/2019/03/15/2주차예습과제/"},{"title":"JAVASCRIPT 스터디 5주차 예습","text":"클래스ES2015에 추가된 클래스는 다른언어에서 말하는 클래스가 아님 프로토타입을 기반으로 하여 만들어진 문법으로 생성자의 기능을 대체 합니다. 클래스사용으로 훨씬 더 깔끔한 문법을 사용할수 있습니다. 생성자와 클래스에 차이점 클래스는 함수로 호출될 수 없습니다. 클래스 선언은 let과 const 처럼 블록 스코프에 선언되며, 호이스팅이 일어나지 않습니다. 클래스는 super 키워드를 사용할수 있습니다. 클래스 문법1234567891011121314151617181920// 클래스 기본 코드// class 선언class Person { // 이전에서 사용하던 생성자 함수는 클래스 안에 `cosntructor`라는 이름으로 정의합니다. // cosntructor는 인스턴스를 생성하고 클래스 속성을 초기화하기 위한 특수한 메소드입니다. constructor({ name, age }) { // 클래스 속성의 선언과 초기화는 반드시 constructor내부에 this.name = name; this.age = age; } // 객체에서 메소드를 정의할 때 사용하던 문법을 그대로 사용하면, 메소드가 자동으로 `Person.prototype`에 저장됩니다. introduce() { return `안녕하세요, 제 이름은 ${this.name}입니다.`; }}// 인스턴스 생성const person = new Person({ name: \"윤아준\", age: 19 });console.log(person.introduce()); // 안녕하세요, 제 이름은 윤아준입니다. Getter, Setter Getter: get 키워드로 정의, 속성을 읽어올때 사용 Setter: set 키워드로 정의, 속성을 변경 할 때 호출 1234567891011121314151617class Account { constructor() { this._balance = 0; } // get 읽기 get balance() { return this._balance; } // set 변경 set balance(newBalance) { this._balance = newBalance; }}const account = new Account();account.balance = 10000;account.balance; // 10000 정적 메소드 정적 메소드: 생성자의 속성에 직접 지정된 메소드를 가지고 정적 메소드라고 합니다. static 키워드를 메소드 이름 앞에 붙여주면 해단 메소드는 정적 메소드가 됩니다. 참고링크https://poiemaweb.com/es6-class","link":"/2019/04/06/5주차예습과제/"},{"title":"JAVASCRIPT 스터디 4주차 예습","text":"Prototype Constructor &amp; new OOP &amp; Instance Prototype자바스크립트는 프로토타입 기반 객체지향 언어입니다. 다른 언어는 클래스 기반 객체지향언어(OOP)입니다.ES2015에 추가된 class문법이 추가되었습니다. 하지만 문법이 추가되었다는 것이지, 자바스크립트가 클래스 기반으로 바뀌었다는 것은 아닙니다. 객체는 함수로부터 시작된다. 즉 객체는 언제나 함수로 생성된다. JavaScript에서는 객체 간에 공유되어야 하는 속성과 메소드를, 프로토타입이라는 기능을 이용해서 효율적으로 저장합니다. 객테에 프로토타입을 지정하면, 프로토타입의 속성을 해당 객체에서 재상용할 수 있습니다. 프로토타입 기능을 이용해 한 객체에서 다른 객체의 기능을 가져와 사용하는 것을 프로토타입 상속이라고 합니다. Constructor &amp; new12function Book() {} //함수const jsBook = new Book(); //함수로 객체 생성, 생성자, Book의 jsBook이라는 인스턴스 생성자는 새로 생성된 객체를 초기화하는 역할을 합니다.new키워드와 함께 사용하는 함수를 가지고 생성자라고 부릅니다. OOP &amp; Instance생성자를 통해 생성된 객체를 그 생성자의 인스턴스라고 합니다. 12//person1이 Person의 인스턴스입니다.person1 instanceof Person; 참고한 자료및 주소https://medium.com/@bluesh55/javascript-prototype-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-f8e67c286b67 Prototype 이제는 이해하자","link":"/2019/03/29/4주차예습과제/"},{"title":"JAVASCRIPT 스터디 3주차 예습","text":"JavaScript Standard built-in Objects에 대하여 조사 및 정리 JavaScript에서의 Object JavaScript Standard built-in Objects (내장객체) 내장 객체란? 자바스크립트가 기본적으로 가지고 있는 객체들을 의미한다. 내장 객체가 중요한 이유는 프로그래밍을 하는데 기본적으로 필요한 도구들이기 때문이다. Object Function Array String Boolean Number Math Date RegExp 같은 객체 생성에 관계가 있는 함수 객체와 메소드로 구성된다. 전역 객체 모든 객체의 최ㅏㅇ위 객체를 의미하며 일반적으로 Browser-side에서는 window, Server-side(Node.js)에서는 global객체를 의미합니다. Function자바스크립트의 모든 함수는 Function 객체이다. 모른 모든 객체들처럼 Function 객체는 new 연산자을 사용해 생성할 수 있습니다. BooleanBoolean 객체는 원시타입 boolean을 위한 레퍼객체이다. Boolean 생성자 함수로 Boolean 객체를 생성할수 있습니다. DOM문서 객체 모델은 현제 웹페이지의 모델을 생성한다. 최상위 객체는 document 객체로 젠체 문서를 표현한다. 또한 이 객체의 자신 객체들은 문서의 다른 요소들을 표현한다.이 객체들은 Standard Built-in Objects가 구성된 후에 구성된다. 참고하기 좋은 링크MDN 표준내장객체poiemaweb Built-in Obj JavaScript에서의 Object (객체)자바스크립트는 객체기반의 스크립트 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다. 원시 타입을 제외한 나머지 값들 (함수, 배열, 정규표현식 등)은 모두 객체이다. 자바스크립트의 객체 키(key)과 값(value)으로 구성된 프로터피들의 집합이다. 프로퍼티의 값으로 자바스크립트에서 사용할 수 있는 모든 값을 사용할 수 있다. 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. 따라서 프로퍼티 값으로 함수를 사용할 수도 있으며 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드라 부른다. 프로퍼티프로퍼티는 프로퍼티 키(이름)와 프로퍼티 값으로 구성된다. 프로퍼티는 프로퍼티 키로 유일하게 식별할 수 있다. 즉, 프로퍼티 키는 프로퍼티를 식별하기 위한 식별자다. 프로퍼티 키 - 프로퍼티 프로퍼티 값 참고하기 좋은 링크 poiemaweb obj","link":"/2019/03/22/3주차예습과제/"},{"title":"JAVASCRIPT 스터디 7주차 예습","text":"Function Closure Call &amp; Apply &amp; Bind 함수 (function)함수는 Function 생성자로 부터 생성되는 객체입니다. 1234567// 복습// JavaScript에서는 function 구문을 통해 함수를 정의할 때 함수의 prototype 속성에 객체가 자동으로 생성되어 저장됩니다.function Person() { // ...}typeof Person.prototype; // 'object' 함수 객체는 두가지 속성을 가지고 있습니다. length - 함수의 매개변수의 개수의 반환 name - 함수의 이름을 반환 (추가) 주인 없는 thisES05 미만에 생성자를 호출시 new 빠트리면 this는 전역을 객체를 가리키게 됩니다. 이를 방지 하기 하기위해 엄격모드를 사용 합니다. 123456789function Person(name) { this.name = name;}// `new`를 빠트린 채 생성자를 호출하면, `this`는 전역 객체를 가리키게 됩니다!Person(\"ria\");// 의도치 않게 전역 객체의 속성이 변경되었습니다.console.log(window.name); // ria 고차함수 ( (Higher-order Function)함수를 인수로 받는 함수 또는 함수를 반환하는 함수를 고차함수라고 합니다.Array의 매소드들이 고차함수입니다. 12345678910// 함수를 인수로 받는 함수// 다른함수의 인수로 넘겨지는 함수를 콜백이라고합니다. 그럼 여기선 ffunction func2(f) { f();}// 함수를 반환하는 함수function func1() { return function() {};} 클로저 (closure)내부함수에서 외부함수의 변수를 사용했을때 외부함수 실행이 끝난뒤에도 변수를 사용할수 있습니다. 이과정에서 외부함수의 변수를 가져다가 사용하는 내부함수와 변수가 저장되는 저장소를 클로저라고 합니다. 클로저를 사용하는 이유? 클로저특성상 데이터를 숨기고 정해진 방법을 통해서만 데이터에 접근할 수 있도록 제한하여서 여러명의 개발자와 협업시 접근제어 및 데이터 보존, 메소드 보존으로 사용합니다. 12345678function func1() { const eye = 2; return function ria() { return eye; };}func1(); // function ria()func1()(); // 2 this 바꿔치기 (Call &amp; Apply &amp; Bind)this는 때에 따라 다른값을 가리킵니다. 그래서 원하는 값을 가리키게 만들어 주기위해 함수 객체의 bind call apply를 사용합니다. bind 메소드를 호출하면 메소드의 인수로 넘겨준 값이 this가 되는 새로운 함수를 반환합니다. 1234567function print(grade) { return `${this.name}님의 점수는 ${grade}`;}const student = { name: \"Ria\" };const printForRia = print.bind(student);printForRia(100); call혹은 apply 메소드를 사용하면 새로운 함수를 만들지 않고 임시적으로 this를 바꿔버립니다.둘의 차이점은 인수를 넘겨주는 방식이 다릅니다.call은 파라미터를 넘길때 콤마로 구문해서 넣어주고 apply는 파라미터를 배열로 넘겨주는 방식입니다. 123456function print(grade) { return `${this.name}님의 점수는 ${grade}`;}const student = { name: \"Ria\" };printForRia.call(student, 100);printForRia.apply(student, [100]);","link":"/2019/04/18/7주차예습과제/"},{"title":"JS30 Array Cardio Day 1","text":"123456789101112131415161718192021222324const inventors = { { first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 }, { first: 'Isaac', last: 'Newton', year: 1643, passed: 1727 }, { first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 }, { first: 'Marie', last: 'Curie', year: 1867, passed: 1934 }, { first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 }, { first: 'Nicolaus', last: 'Copernicus', year: 1473, passed: 1543 }, { first: 'Max', last: 'Planck', year: 1858, passed: 1947 }, { first: 'Katherine', last: 'Blodgett', year: 1898, passed: 1979 }, { first: 'Ada', last: 'Lovelace', year: 1815, passed: 1852 }, { first: 'Sarah E.', last: 'Goode', year: 1855, passed: 1905 }, { first: 'Lise', last: 'Meitner', year: 1878, passed: 1968 }, { first: 'Hanna', last: 'Hammarström', year: 1829, passed: 1909 }} const people = ['Beck, Glenn', 'Becker, Carl', 'Beckett, Samuel', 'Beddoes, Mick', 'Beecher, Henry', 'Beethoven, Ludwig', 'Begin, Menachem', 'Belloc, Hilaire', 'Bellow, Saul', 'Benchley, Robert', 'Benenson, Peter', 'Ben-Gurion, David', 'Benjamin, Walter', 'Benn, Tony', 'Bennington, Chester', 'Benson, Leana', 'Bent, Silas', 'Bentsen, Lloyd', 'Berger, Ric', 'Bergman, Ingmar', 'Berio, Luciano', 'Berle, Milton', 'Berlin, Irving', 'Berne, Eric', 'Bernhard, Sandra', 'Berra, Yogi', 'Berry, Halle', 'Berry, Wendell', 'Bethea, Erin', 'Bevan, Aneurin', 'Bevel, Ken', 'Biden, Joseph', 'Bierce, Ambrose', 'Biko, Steve', 'Billings, Josh', 'Biondo, Frank', 'Birrell, Augustine', 'Black, Elk', 'Blair, Robert', 'Blair, Tony', 'Blake, William']; // 1500년도 보다 크거나 같고 1600보다 작은 데이터 필터 // filter메소드: 배열에서 원하는 요소만 골라내어 새로운 배열을 생성 // 진리값을 반황하는 함수를 주어야 합니다. // (현재 요소, 인덱스, 배열)의 세인수를 받습니다. let fifteen = inventors.filter(inventor =&gt; (inventor.year &gt;= 1500 &amp;&amp; inventor.year &lt; 1600)); cosole.table(fifteen);","link":"/2019/03/31/ArrayCardioDay1/"},{"title":"07_ArrayCardioDay2","text":"1234567891011121314151617181920212223242526272829303132333435363738394041const people = [ { name: \"Wes\", year: 1988 }, { name: \"Kait\", year: 1986 }, { name: \"Irv\", year: 1970 }, { name: \"Lux\", year: 2015 }];const comments = [ { text: \"Love this!\", id: 523423 }, { text: \"Super good\", id: 823423 }, { text: \"You are the best\", id: 2039842 }, { text: \"Ramen is my fav food ever\", id: 123523 }, { text: \"Nice Nice Nice!\", id: 542328 }]; some는 predicate을 인수로 받아서, 조건을 만족하는 요소가 하나라도 있는지 판별후, true, false 반환(현재 요소, 인덱스, 배열) Date.prototype.getFullYear()주어진 날짜의 연도(4자리 수)를 현지 시간에 맞춰 반환합니다. 123456789// Original// 19살보다 많은지 판별const isAdult = people.some(function(person) { // 금년도 날짜 const currentYear = new Date().getFullYear(); if (currentYear - person.year &gt;= 19) { return true; }}); 1234567891011121314// 화살표함수로const isAdult = people.some(person =&gt; { const currentYear = new Date().getFullYear(); return currentYear - person.year &gt;= 19;});console.log({ isAdult });// 더 짧게 화살표함수로const isAdult = people.some( person =&gt; new Date().getFullYear() - person.year &gt;= 19);console.log({ isAdult }); // true every는 모든 요소가 조건을 만족하는 지 검사 123456// 모든 사람const allAdults = people.every( person =&gt; new Date().getFullYear() - person.year &gt;= 19);console.log({ allAdults }); // false find 특정 조건을 만족하는 요소를 찾을 수 있습니다.조건을 찾으면 요소를 반환조건을 찾지 못하면 undefined 123const comment = comments.find(comment =&gt; comment.id === 823423);console.log(comment); // id: 823423 인 객체 반환 findIndex 메소드를 사용하면 특정 조건을 만족하는 요소를 찾을 수 있습니다.조건을 찾으면 요소의 인덱스를 반환조건을 찾지 못하면 -1 123const index = comments.findIndex(comment =&gt; comment.id === 823423);console.log(index); // 1 splice 메소드나는 바꿔치기를 통해 제거된 요소들을 반환합니다. 12const newComments = [...comments.slice(0, index), ...comments.slice(index + 1)];console.log(newComments); //","link":"/2019/04/20/ArrayCardioDay2/"},{"title":"JS30 CSS Clock","text":"CSSClock1234567891011.hand { transform: rotate(90deg); /*시계 방향으로 90도 회전*/ transform-origin: 100%; /*기준점의 오른쪽 끝으로해서 돌아간다.*/ transition: 0.05s; /*transition-duration: 트랜지션이 일어나는 지속 시간*/ transition-timing-function: cubic-bezier( 0.61, -0.21, 1, -0.68 ); /*시간에 따른 파라미터 값의 변화율을 명시하는 함수, transition의 속도를 조절합니다.*/} transform (변형)transform 속성을 사용하여 요소의 스타일을 자유롭게 바꿀수 있습니다. 해당 요소를 움직입니다 해당 요소를 회전시킵니다 해당 요소의 크기를 변경합니다 해당 요소를 기울입니다 transform 메소드 translate(x, y) : 현재 위치에서 해당 요소를 주어진 x축과 y축의 거리만큼 이동시킵니다. rotate(Ndeg) : 주어진 각도만큼 시계 방향(양수+)이나 반시계 방향(음수-)으로 회전시킵니다. scale(x, y) : 요소의 크기를 주어진 배율만큼 늘리거나 줄입니다. 기본값은 1이고, 1보다 크면 크기를 늘리고, 1보다 작으면 크기를 줄입니다. skew(Xdeg, Ydeg) : 주어진 각도 만큼 x, y축 방향으로 기울입니다. matrix() : 모든 2D transform 메소드를 한 줄에 설정할 수 있도록 해줍니다. translate (전환)CSS 속성을변경할 때, 변경이 즉시 영향을 미치게 하는 대신 그 속성의 변화가 일정 기간에 걸쳐 일어나도록 할 수 있습니다. setInterval123456const clockSet = () =&gt; { console.log(\"hi\");};// setInterval 타이ㅂ머 식별자를 반환합니다.// 1초마다 clockSet을 출력합니다.setInterval(clockSet, 1000); new Date()new Date(year, month, day, hour, minutes, seconds, milliseconds) - 년, 월, 일, 시, 분, 초, 밀리초를 직접 입력해서 Date객체를 생성할 수도 있습니다. 12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; // Selector 지정 const secondHand = document.querySelector(\".second-hand\"); const minHand = document.querySelector(\".min-hand\"); const hourHand = document.quertSelector(\"./hour-hand\"); function setDate() { // 현재 시각을 나타내는 Date 객체를 반환 const now = new Date(); // 초를 리턴하는 메소드 /* 현재원의 100% 는 360도 1시간 =&gt; 12칸 , 1분 =&gt; 총 60칸 , 1초 =&gt; 총 60칸 (현재 값을 /각칸개수로) * 360 = [전체 기준의 움직이는 간격] */ const seconds = now.getSeconds(); const secondsDegrees = (seconds / 60) * 360 + 90; secondHand.style.transform = `rotate(${secondsDegrees})deg)`; console.log(seconds); // 12시 기준 90deg에 360 기준으로 60칸이 초는 움직이므로 (초/60) * 360 + 90을 해주면 한칸움직이는 간격을 구할수있다. // 분을 리턴하는 메소드 const mins = now.getMinutes(); const minsDegrees = (mins / 60) * 360 + 90; minHand.style.transform = `rotate(${minsDegrees}deg)`; // 시간을 리턴하는 메소드 const hour = now.getHours(); const hourDegrees = (hour / 12) * 360 + 90; hourHand.style.transform = `rotate(${hourDegrees}deg)`; x; } setInterval(setDate, 1000);&lt;/script&gt;","link":"/2019/03/23/CSSClock/"},{"title":"Flex Panel Gallery","text":"123456789101112131415161718192021222324252627&lt;div class=\"panels\"&gt; &lt;div class=\"panel panel1\"&gt; &lt;p&gt;Hey&lt;/p&gt; &lt;p&gt;Let's&lt;/p&gt; &lt;p&gt;Dance&lt;/p&gt; &lt;/div&gt; &lt;div class=\"panel panel2\"&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;Take&lt;/p&gt; &lt;p&gt;Receive&lt;/p&gt; &lt;/div&gt; &lt;div class=\"panel panel3\"&gt; &lt;p&gt;Experience&lt;/p&gt; &lt;p&gt;It&lt;/p&gt; &lt;p&gt;Today&lt;/p&gt; &lt;/div&gt; &lt;div class=\"panel panel4\"&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;All&lt;/p&gt; &lt;p&gt;You can&lt;/p&gt; &lt;/div&gt; &lt;div class=\"panel panel5\"&gt; &lt;p&gt;Life&lt;/p&gt; &lt;p&gt;In&lt;/p&gt; &lt;p&gt;Motion&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; flex: flex-grow속성과 flex-shrink속성 그리고 flex-basis속성을 일괄적으로 지정할 수 있는 대표 속성입니다. flex-grow: flex로 정의된 부모요소가 자식 요소보다 크거나 작을 경우, 자식 요소의 크기를 조정하는 방법으로 자식 요소에 확대 비율을 지정하여 부모요소의 크기에 맞게 자동으로 크기를 조정합니다.(기본값:0) flex-shrink: flex로 정의된 부모요소가 자식 요소보다 크거나 작을 경우, 자식 요소의 크기를 조정하는 방법으로 자식 요소에 축소 비율을 지정하여 부모요소의 크기에 맞게 자동으로 크기를 조정합니다.(기본값:1) 1234567891011.panel &gt; * { margin: 0; width: 100%; transition: transform 0.5s; border: 1px solid red; flex: 1 0 auto; display: flex; justify-content: center; align-items: center;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110html { box-sizing: border-box; background: #ffc600; font-family: \"helvetica neue\"; font-size: 20px; font-weight: 200;}body { margin: 0;}*,*:before,*:after { box-sizing: inherit;}.panels { min-height: 100vh; overflow: hidden; display: flex;}.panel { background: #6b0f9c; box-shadow: inset 0 0 0 5px rgba(255, 255, 255, 0.1); color: white; text-align: center; align-items: center; /* Safari transitionend event.propertyName === flex */ /* Chrome + FF transitionend event.propertyName === flex-grow */ transition: font-size 0.7s cubic-bezier(0.61, -0.19, 0.7, -0.11), flex 0.7s cubic-bezier(0.61, -0.19, 0.7, -0.11), background 0.2s; font-size: 20px; background-size: cover; background-position: center; flex: 1; justify-content: center; align-items: center; display: flex; flex-direction: column;}.panel1 { background-image: url(https://source.unsplash.com/gYl-UtwNg_I/1500x1500);}.panel2 { background-image: url(https://source.unsplash.com/rFKUFzjPYiQ/1500x1500);}.panel3 { background-image: url(https://images.unsplash.com/photo-1465188162913-8fb5709d6d57?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;w=1500&amp;h=1500&amp;fit=crop&amp;s=967e8a713a4e395260793fc8c802901d);}.panel4 { background-image: url(https://source.unsplash.com/ITjiVXcwVng/1500x1500);}.panel5 { background-image: url(https://source.unsplash.com/3MNzGlQM7qs/1500x1500);}/* Flex items */.panel &gt; * { margin: 0; width: 100%; transition: transform 0.5s; border: 1px solid red; flex: 1 0 auto; display: flex; justify-content: center; align-items: center;}.panel &gt; *:first-child { transform: translateY(-100%);}.panel.open-active &gt; *:first-child { transform: translateY(0);}.panel &gt; *:last-child { transform: translateY(100%);}.panel.open-active &gt; *:last-child { transform: translateY(0);}.panel p { text-transform: uppercase; font-family: \"Amatic SC\", cursive; text-shadow: 0 0 4px rgba(0, 0, 0, 0.72), 0 0 14px rgba(0, 0, 0, 0.45); font-size: 2em;}.panel p:nth-child(2) { font-size: 4em;}.panel.open { font-size: 40px; flex: 5;} transitionend 이벤트: CSS를 전환이 완료되면 transitionend이벤트가 발생한다. 1panels.forEach(panel =&gt; panel.addEventListener(\"transitionend\", toggleActive)); 12345678910111213141516function toggleOpen() { console.log(\"Hello\"); this.classList.toggle(\"open\");}function toggleActive(e) { console.log(e); console.log(e.propertyName); if (e.propertyName.includes(\"flex\")) { this.classList.toggle(\"open-active\"); }}const panels = document.querySelectorAll(\".panel\");panels.forEach(panel =&gt; panel.addEventListener(\"click\", toggleOpen));panels.forEach(panel =&gt; panel.addEventListener(\"transitionend\", toggleActive));","link":"/2019/04/10/Flex Panel Gallery/"},{"title":"FunWithHTML5Canvas","text":"1&lt;canvas id=\"draw\" width=\"800\" height=\"800\"&gt;&lt;/canvas&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const canvas = document.querySelector(\"#draw\");// 2D로 랜더링 컨텍스트와 그리기함수 사용const ctx = canvas.getContext(\"2d\");canvas.width = window.innerWidth;canvas.height = window.innerHeight;ctx.strokeStyle = \"#BADA55\"; // strokeStyle? 색상?ctx.lineJoin = \"round\"; // 선이 만나는 지점ctx.lineCap = \"round\"; // 선이 끝나느 지점ctx.lineWidth = 50; // 선의 두께// different brush effects:ctx.globalCompositeOperation = \"multiply\";let isDrawing = false;let lastX = 0;let lastY = 0;let hue = 0;let direction = true;function draw(e) { // stop the fn from running when they are not moused down if (!isDrawing) return; ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`; ctx.beginPath(); // start from ctx.moveTo(lastX, lastY); // go to ctx.lineTo(e.offsetX, e.offsetY); ctx.stroke(); [lastX, lastY] = [e.offsetX, e.offsetY]; hue++; if (hue &gt;= 360) { hue = 0; } if (ctx.lineWidth &gt;= 100 || ctx.lineWidth &lt;= 1) { direction = !direction; } if (direction) { ctx.lineWidth++; } else { ctx.lineWidth--; }}canvas.addEventListener(\"mousedown\", e =&gt; { isDrawing = true; [lastX, lastY] = [e.offsetX, e.offsetY];});canvas.addEventListener(\"mousemove\", draw);canvas.addEventListener(\"mouseup\", () =&gt; (isDrawing = false));canvas.addEventListener(\"mouseout\", () =&gt; (isDrawing = false)); 좀 더 코드를 봐야할듯… 신기함","link":"/2019/04/21/FunWithHTML5Canvas/"},{"title":"Hexo 블로그 만들기","text":"Hexo와 Github io로 시작하는 블로그 만들기 바로 시작합니다. git repository 만들기 Repository 이름은 USERNAME.github.io USERNAME : Github 사용자명 Public / Private 중 Public 선택 hexo 설치1npm install hexo-cli -g 명령어 npm을 통해 hexo-cli 모듈을 global하게 설치한다는 명령어 입니다. 기본 블로그 구조 생성 새로운 포스트 생성 github page에 올리기 위해 markdown을 html로 변환 local(내 컴퓨터)에서 실행 테스트 github에 업로드 Hexo 블로그 생성블로그와 관련된 모든 행동은 hexo명령어로 시작됩니다. 이제 블로그를 생성해 보겠습니다. 먼저 적당하게 폴더를 하나 만든 후에 그 폴더에 접근 후 명령어를 입력합니다. 123$ hexo init myBlog$ cd myBlog$ npm install 만들어진 블로그 폴더를 열어 내용을 확인해봅니다. node_modules - hexo 블로그 사용에 필요한 기본적인 node.js 모듈 scaffolds - hexo 페이지를 구성할 기본적인 markdown파일 source - 실제로 포스트를 작성한 파일(markdown)과 이미지 등의 리소스가 저장되는 경로 theme - 테마 파일이 저장되는 경로로 처음 hexo를 설치하게 되면 landscape 테마가 설치 .gitignore - git을 통해 github에 블로그를 업로드할 때 업로드를 제외할 파일의 목록을 정의하는 파일 _config.yml - hexo 블로그의 옵션을 지정하는 설정 파일 Hexo 블로그 Github에 연동하기hexo를 사용하면 별도의 git 명령어가 없이도 알아서 github에 업로드를 해줍니다. 그러기 위해서는 hexo와 github간의 연결고리가 있어야 하는데 이 연결고리는 _config.yml을 통해 지정할 수 있습니다. _config.yml을 열어봅니다. 여러 설정이 있지만 일단 넘어가고 마지막에 있는 #Depolyment를 봅니다. 여기에 deploy에 처음에 만든 github repository를 적어주면 github와 연동이 됩니다. 12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/계정이름/계정이름.github.io.git 그리고 hexo에서 github에 업로드하기 위해 필요한 npm모듈을 설치합니다. 생성한 블로그 폴더 경로로 이동하여 명령 창을 실행하여 npm명령어를 입력합니다. 1$ npm install hexo-deployer-git --save 포스트 생성하기이제 포스트를 작성해봅시다. 생성한 블로그 폴더 경로로 이동하여 명령 창을 실행하여 아래처럼 입력합니다. 1$ hexo new post 포스트 파일명 hexo의 new post [포스트 파일명]명령어를 입력하게 되면 포스팅이 가능한 파일을 만들어 줍니다. 단 하나의 명령어 하나로 포스트 파일을 아주 쉽게 만들수 있습니다. markdown언어를 사용하여 글을 작성해야 합니다. 12345---title: first-postdate: 2017-06-30 13:53:51tags:--- title - 실제 페이지에 출력될 포스트의 제목date - 포스트를 생성한 날짜(hexo 빌드 시 date 날짜별로 폴더가 생성)tags - hexo 블로그에서 관리 될 tag 목록 Hexo 빌드1$ hexo generate 또는 hexo g 로컬에서 확인하기1$ hexo server localhost:4000 에 접속하면 방금 만든 블로그를 확인할 수 있습니다. hexo-cli 설치하실 때 -g 부분을 빠뜨리면 hexo라는 명령어가 인식하지 않습니다.만약 빼먹었다면 npm uninstall hexo-cli를 하시고 다시 설치하시면 됩니다. Github에 업로드하기1$ hexo deploy 또는 hexo d 위의 명령어를 통해 github에 업로드를 하며, generate 명령어와 동시에 작성할 수 있습니다. 1$ hexo g --d 간혹 hexo의 deploy기능을 통해 정상적으로 배포가 되었음에도 불구하고 페이지가 업데이트 되지 않는 현상이 있는데, 이 경우에는 아래와 같이 페이지를 clean후에 배포를 하면 해결됩니다. 12$ hexo clean후 재배포 Hexo 테마 적용 하기USERNAME.github.io를 통해 성공적으로 블로그 접속이 되었다면, 멋진 디자인을 적용한 테마(Theme)를 적용하고 싶을 것이다. Hexo에서는 아래의 페이지에서 다양한 Theme가 적용된 페이지를 소개하고 있습니다. https://hexo.io/themes/ Theme를 적용하기 위해서는 hexo-theme-chiangmai Github 페이지에서 자세한 내용을 확인 할 수 있다. 주의사항으로는 Theme를 적용하기 위해서는 아래와 같이 Repository 상태를 clean한 이후에 재배포 해야만 한다. 12$ hexo clean$ hexo deploy --generate","link":"/2019/01/08/Hexo블로그만들기/"},{"title":"Playing with CSS Variables and JS","text":"Playing with CSS Variables and JS12345678910111213141516171819202122232425262728293031&lt;!-- HTML --&gt;&lt;h2&gt;Update CSS Variables with &lt;span class=\"hl\"&gt;JS&lt;/span&gt;&lt;/h2&gt;&lt;div class=\"controls\"&gt; &lt;label for=\"spacing\"&gt;Spacing:&lt;/label&gt; &lt;input id=\"spacing\" type=\"range\" name=\"spacing\" min=\"10\" max=\"200\" value=\"10\" data-sizing=\"px\" /&gt; &lt;label for=\"blur\"&gt;Blur:&lt;/label&gt; &lt;input id=\"blur\" type=\"range\" name=\"blur\" min=\"0\" max=\"25\" value=\"0\" data-sizing=\"px\" /&gt; &lt;label for=\"base\"&gt;Base Color&lt;/label&gt; &lt;input id=\"base\" type=\"color\" name=\"base\" value=\"#ffc600\" /&gt;&lt;/div&gt;&lt;img src=\"https://source.unsplash.com/7bwQXzbF6KE/800x500\" /&gt; 12345678910111213141516/* css */:root { --base: #ffc600; --spacing: 10px; --blur: 0px;}img { padding: var(--spacing); background: var(--base); filter: blur(var(--blur));}.hl { color: var(--base);} element.style.setProperty(property, value)setProperty() 메소드를 사용하여 자바스크립트에서 css커스텀 속성을 읽고 쓸 수 있습니다. 12345678910const inputs = document.querySelectorAll(\".controls input\");// input range의 변화값 값 인지function handleUpdate(e) { const suffix = e.dataset.sizing || \"\"; document.documentElement.style.setProperty(`--${e.name}`,e.value + suffix);}inputs.forEach(input =&gt; input.addEventListener(\"change\", handleUpdate));inputs.forEach(input =&gt; input.addEventListener(\"mousemove\", handleUpdate));","link":"/2019/04/06/Playing with CSS Variables and JS/"},{"title":"JAVASCRIPT 값 더 알아보기","text":"값 더 알아보기const와 let의 차이 let은 재대입 가능, const는 재대입 불가 const는 선언과 대입을 동시 const와 let의 공통점 let과 const 둘 다 같은 이름을 갖는 변수의 재선언을 허용하지 않음 변수가 선언되기 전에 참조하여고 하면 에러 블록 스코프를 갖음 var와 let,const의 차이 var는 재선언 가능 let, const는 블록 스코프, var는 함수 스코프 const let var 스코프 블록 스코프 블록 스코프 함수 스코프 재대입 X O O 재선언 X X O 호이스팅 X X O 사용 권장 1순위 2순위 3순위 전역변수(글로벌 변수)를 사용하면 안되는 이유 라이브러리를 사용, 큰 프로젝트 소스를 나누어서 관리할때 충돌이 일어날수 있습니다. 서버의 중요한 데이터나 공개하고 싶지 않은 데이터를 처리할때(해캥이나 보안적 측면) 브라우저에는 기본적으로 자바스크립트 콘솔이나 디버깅 둘이 내장되어 있으므로 이를 이용하면 소스는 기본이고, 자바스크립트 변수값들도 쉽게 알아낼수 있습니다. 메모리 관리 측면에서 좋지 않습니다. 예방방법 클로저 이용 모듈화 엄격모드이용 (엄격모드- 엄격하게 문법을 검사하겠다. 전역변수 사용 못하게 함) 12345678910111213141516171819202122232425// 글로벌 변수 선언 예시 1let globalVar = \"aaa\";// 글로벌 변수 선언 예시 2// i와 globalVar3 둘 다 글로벌 변수// var는 함수 스코프이기 때문for (var i = 0; i &lt; 10; i++) { var globalVar3 = \"bbb\";}// 글로벌 변수 선언 예시 3function testFuc() { globalVar4 = \"ccc\"; for (j = 0; j &lt; 10; j++) { // ... }}testFuc();console.log(globalVar); // aaaconsole.log(i); //10console.log(globalVar3); //bbbconsole.log(globalVar4); //cccconsole.log(j); //10 전역객체 Window JavaScipt 구동 환경은 모두 전역 객체라는 특별한 객체를 갖고 있습니다. 전역 변수가 선언되면, 이 변수는 또한 전역 객체의 속성이 되어 전역 객체를 통해서 접근할 수 있다. 전역 객체의 이름은 javaScipt 구동 환경마다 다릅니다. 구동환경 전역 객체 이름 웹 브라우저 window 웹 워커 self Node.js global scope 변수는 코드의 일정 범위 안에서 유효하다는 성질을 가지고 있는데 이러한 특정 변수가 유효한 코드상의 유효 범위를 가지고 스코프라고 합니다. 현재 접근할 수 있는 변수들의 범위 현재 위치에서 볼 수 있는 변수들의 범위 변수가 스코프 안에 선언되었으면 해당 스코프 안에서 변수에 접근하여 일고 쓸수 있습니다. 하지만 스코프 밖에서는 해당 변수에 접근할 수 없습니다. 1234따로 알아볼것* scope가 조금 다른 catch* catch와 with의 예외 - catch와 with의 경우 인자로 포함되는 error/inScope등의 변수들은 scope 안에서만 사용가능하나 그 내부에 선언한 변수들은 global scope를 따른다. 함수scope와 블록scope함수scope는 함수 단위로 범위를 지정하며 var가 가지고 있는 스코프입니다.블록scope는 중괄호{} 단위로 범위를 지정하며 let,const가 가지고 있는 스코프입니다. 1234567891011121314151617// 함수scopefunction scopeTest() { var is = true; if (is) { var is = false; } for (var i = 0; i &lt;= 5; i++) { var inFor = i; } console.log(inFor); console.log(is);}scopeTest(); 1234567891011121314151617// 블록scopefunction scopeTest() { let is = true; if (is) { let is = false; } for (let i = 0; i &lt;= 5; i++) { let inFor = i; } console.log(is); console.log(inFor);}scopeTest(); 스코프 체인식별자를 찾는 일련의 과정 변수가 스코프 안에 선언되지 않았다면, 그 변수를 찾기 위해 부모 스코프로 올라가고, 거기에도 없다면 또 부모 스코프에 올라가서 찾습니다. 호이스팅var 변수의 선언부를 제일 위로 끌어올린다. 선언부만! let, const 변수는 호이스팅 기능이 없다. 함수가 함수 선언식으로 선언되면, 현대 스코프의 최상단으로 호이스팅 됩니다. 함수 또는 var로 선언된 변수 var는 함수 스코프이기 떄문에 함수 내부에서 맨 상단으로 끌어올려짐. 반면 함수가 함수 표현식으로 선언되면, 함수는 현재 스코프의 최상단으로 호이스팅되지 않습니다. 네스팅된 스코프에서 렉시컬 스코핑함수가 다른 함수 내부에서 정의되었다면, 내부 함수는 외부 함수의 변수에 접근할 수 있습니다. 이런 행동을 렉시컬 스코핑이라고 합니다. 읽은 자료 (혹은 참고한 링크)https://gist.github.com/LeoHeo/7c2a2a6dbcf80becaaa1e61e90091e5d 자바스크립트에서 메모리 누수의 4가지 형태 렉시컬 스코프","link":"/2019/01/10/JAVASCRIPT 심화 1/"},{"title":"JAVASCRIPT Prototype","text":"자바스크립트는 프로토타입 기반 언어라고 불립니다. Prototype프로그램에서는 아주 많은 비슷한 객체들이 존재하고 이 객체들은 아마도 각각 다른 속성을 가지고 있습니다. 하지만 그들 중에도 공통으로사용하는 속성과 메소드가 있겠죠. JavaScript에서는 이렇게 객체 간에 공유되어야 하는 속성과 메소드를, 프로토타입이라는 기능을 이용해 효율적으로 저장합니다. 사전적 의미: “원형” “원래의 모습” 말 그대로 무엇의 원형을 나타내는지 생각해보면 될것. prototype vs Class자바스크립트에는 클래스라는 개념이 없습니다. 대신 프로토타입이라는 것이 존재합니다.클래스가 없으니 기본적으로 상속도 없습니다. 그래서 프로코타입을 기반으로 상속을 흉내내도록 구현합니다. 최근의 ES2015에서 class 문법이 추가되었습니다. 하지만 문법이 추가되었다는거임… 자바스크립트가 클래스 기반으로 바뀌었다는 것은 아닙니다. Prototype Link와 Prototype Object자바스크립트에는 Prototype Link와 Prototype Object라는 것이 존재합니다. 그리고 이 둘을 통틀어 Prototype이라고 부릅니다. Prototype Object객체는 언제나 함수(Function)로 생성됩니다. 12function Person() {} // 함수let personObject = new Person(); // 함수로 객체 생성 personObject 객체는 Person이라는 함수로 생성된 객체입니다. 언제나 객체는 함수에서 시작됩니다. 함수랑 전혀 상관없는 코드로 보이지만 서로 같은 코드입니다. 12let obj = {};let obj = new Object(); 위 코드는 Object가 자바스크립트에서 기본적으로 제공하는 함수입니다.Odject와 마찬가지로 function, Array도 모두 함수로 정의되어 있습니다. 함수가 정의될 때는 2가지 일이 동시에 이루어집니다. 1. 해당 함수에 Constructor(생성자) 자격 부여Constructor 자격이 부여되면 new를 통해 객체를 만들어 낼 수 있게 됩니다. 이것이 함수만 new 키워드를 사용할 수 있는 이유입니다. 2. 해당 함수의 Prototype Object 생성 및 연결함수를 정의하면 함수만 생성되는것이 아니라 Prototype Object도 같이 생성이 됩니다. [출처: [Javascript ] 프로토타입 이해하기] 읽은 자료 (혹은 참고한 링크)[Javascript ] 프로토타입 이해하기","link":"/2019/01/11/Prototype/"}],"tags":[{"name":"JS30","slug":"JS30","link":"/tags/JS30/"},{"name":"Grammar, Type (Primitive, Reference), Value, Expression,  Statement, Memory, Truthy & Falsy, Scope","slug":"Grammar-Type-Primitive-Reference-Value-Expression-Statement-Memory-Truthy-Falsy-Scope","link":"/tags/Grammar-Type-Primitive-Reference-Value-Expression-Statement-Memory-Truthy-Falsy-Scope/"},{"name":"값, 식, 문, Primitive Type, Reference type, Truthy, Falsy","slug":"값-식-문-Primitive-Type-Reference-type-Truthy-Falsy","link":"/tags/값-식-문-Primitive-Type-Reference-type-Truthy-Falsy/"},{"name":"클래스","slug":"클래스","link":"/tags/클래스/"},{"name":"프로토타입, 생성자, 객체지향, 인스턴스","slug":"프로토타입-생성자-객체지향-인스턴스","link":"/tags/프로토타입-생성자-객체지향-인스턴스/"},{"name":"내장객체, 객체","slug":"내장객체-객체","link":"/tags/내장객체-객체/"},{"name":"함수, 클로저, this바뀌치기","slug":"함수-클로저-this바뀌치기","link":"/tags/함수-클로저-this바뀌치기/"},{"name":"Hexo, 블로그, Markdown","slug":"Hexo-블로그-Markdown","link":"/tags/Hexo-블로그-Markdown/"},{"name":"값 더 알아보기,JAVASCRIPT, const와 let 비교, var와 let,const 비교,scope, 블록스코프, 함수스코프, 호이스팅, 전역변수, 전역객체, 윈시타입, 참조타입, 불변성, 래처객체, 렉시컬 스코프","slug":"값-더-알아보기-JAVASCRIPT-const와-let-비교-var와-let-const-비교-scope-블록스코프-함수스코프-호이스팅-전역변수-전역객체-윈시타입-참조타입-불변성-래처객체-렉시컬-스코프","link":"/tags/값-더-알아보기-JAVASCRIPT-const와-let-비교-var와-let-const-비교-scope-블록스코프-함수스코프-호이스팅-전역변수-전역객체-윈시타입-참조타입-불변성-래처객체-렉시컬-스코프/"},{"name":"JAVASCRIPT, Object, 객체, Prototype","slug":"JAVASCRIPT-Object-객체-Prototype","link":"/tags/JAVASCRIPT-Object-객체-Prototype/"}],"categories":[]}